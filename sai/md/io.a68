#include	"sai/md/io.h"
#include	"sai/input.h"
#include	"sai/input_bits.h"

; "Time" to allow TH pin to settle
#define SAI_MD_PAD_NOP_COUNT 3

#if SAI_PLAYER_COUNT > 3
#error "SAI_PLAYER_COUNT cannot exceed 3 for MD target!"
#endif  // SAI_PLAYER_COUNT

.macro	th_wait
	.rept	SAI_MD_PAD_NOP_COUNT
	nop
	.endr
.endm

	.section	.text

//
// Z80 Functions
//

	.global	sai_md_z80_init
sai_md_z80_init:
	calla6_safe sai_min_md_z80_init
	rts

	.global	sai_min_md_z80_init
sai_min_md_z80_init:
	lea	MD_Z80_WRAM, a0

	SAI_MD_Z80_RESET_ASSERT
	SAI_MD_Z80_BUSREQ
	SAI_MD_Z80_RESET_DEASSERT

	moveq	#0, d0
	move.w	#(MD_Z80_WRAM_SIZE/4)-1, d1
0:
	.rept	4
	move.b	d0, (a0)+
	.endr
	dbf	d1, 0b

	lea	MD_Z80_WRAM, a0
	lea	z80_stub(pc), a1
	.rept	3
	move.b	(a1)+, (a0)+
	.endr

	SAI_MD_Z80_RESET_WAIT
	SAI_MD_Z80_RESET_DEASSERT
	SAI_MD_Z80_BUSREL

	jmp	(a6)

z80_stub:
	dc.b	$F3       ; di
	dc.b	$18, $FE  ; jr $

	.align	2

//
// Gamepad functions
//

	.global	sai_md_pad_init
sai_md_pad_init:
	calla6_safe sai_min_md_pad_init
	rts

	.global	sai_min_md_pad_init
; a6.l = return
sai_min_md_pad_init:
	lea	MD_IO_DATA1, a0
	moveq	#0, d0
	.rept	SAI_PLAYER_COUNT
	move.b	d0, (a0)  ; Clear output registers
	move.b	#$40, (MD_IO_CTRL1-MD_IO_DATA1)(a0)  ; Set TH pin as output
	addq.l	#2, a0
	.endr
	jmp	(a6)
	

; a0 = SaiInput
; a1 points to the pad data port (byte address).
	.global	update_pad_sub
update_pad_sub:

	SAI_MD_Z80_BUSREQ
	; First step - x1CBRLDU into d0
	move.b	#$40, (a1)  ; TH hi
	th_wait
	move.b	(a1), d0
	; Second step - x0SA00DU into d1
	move.b	#$00, (a1)  ; TH low
	th_wait
	ori.w	#$FFC0, d0
	move.b	(a1), d1
	; If the pad doesn't positively identify as an MD pad (bits 2 and 3
	; cleared), then don't proceed to read later phases.
	; TODO: Gracefully handle peripherals like Mega Mouse, etc.
	btst.b	#2, d1
	bne.s	store_pad_unplugged
	btst.b	#3, d1
	bne.s	store_pad_unplugged
	; Proceed to use the second phase data.
	lsl.b	#2, d1
	ori.w	#$FF3F, d1
	and.w	d1, d0
	; d0 contains a full 3-button controller's worth now.
	; Third step - write TH high and disregard data.
	move.b	#$40, (a1)  ; TH hi
	th_wait
	; Sixth step - write TH low, and use lower nybble to check pad type.
	move.b	#$00, (a1)  ; TH low
	th_wait
	move.b	(a1), d1
	; If the lower four bits are non-zero, it's not a 6-button pad.
	; final step - write TH high, read extra buttons
	move.b	#$40, (a1)  ; TH hi
	th_wait
	andi.b	#$0F, d1
	bne.s	store_pad
	move.b	(a1), d1
	; Shift buttons into place in upper byte and mask off other bits
	lsl.w	#8, d1
	ori.w	#$F0FF, d1
	and.w	d1, d0
	; Mark highest bit to indicate a 6-button controller.
	andi.w	#~SAI_BTN_6B, d0
	bra.s	store_pad

store_pad_unplugged:
	; Mark second-highest bit for "unplugged/maybe sms" status.
	andi.w	#~SAI_BTN_UNPLUGGED, d0
	; Fall-through intended.
store_pad:
	move.b	#$00, (a1)  ; TH back to low
	SAI_MD_Z80_BUSREL
	; Invert buttons so `1` indicates a push.
	not.w	d0
	move.w	d0, SaiInput.now(a0)
	rts

	.global	sai_md_pad_poll
sai_md_pad_poll:
	lea	g_sai_in, a0
	lea	MD_IO_DATA1, a1
	.rept	SAI_PLAYER_COUNT
	bsr.w	update_pad_sub
	lea	SaiInput.len(a0), a0
	addq.l	#2, a1  ; next pad
	.endr
	rts

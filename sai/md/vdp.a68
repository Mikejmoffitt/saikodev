#include "sai/memmap.h"
#include "sai/md/vdp.h"

	.global	sai_vdp_update_scroll_base

	.global	g_sai_vdp_ntbase
	.global	g_sai_vdp_sprbase
	.global	g_sai_vdp_hsbase
	.global	g_sai_vdp_reg_mode
	.global	g_sai_vdp_reg_spcga
	.global	g_sai_vdp_reg_bg_color
	.global	g_sai_vdp_reg_planesize

//
// Storage
//
	.section	.data
g_sai_vdp_reg_mode:
	dc.w VDP_REGST(VDP_MODESET1, VDP_MODESET1_DEFAULT)
	dc.w VDP_REGST(VDP_MODESET2, VDP_MODESET2_DEFAULT)
	dc.w VDP_REGST(VDP_MODESET3, VDP_MODESET3_DEFAULT)
	dc.w VDP_REGST(VDP_MODESET4, VDP_MODESET4_DEFAULT)
g_sai_vdp_ntbase:
	dc.l VRAM_SCRA_BASE_DEFAULT
	dc.l VRAM_SCRB_BASE_DEFAULT
	dc.l VRAM_SCRW_BASE_DEFAULT
g_sai_vdp_sprbase:
	dc.l VRAM_SPR_BASE_DEFAULT
g_sai_vdp_hsbase:
	dc.l VRAM_HSCR_BASE_DEFAULT

//
// Startup
//
	.section	.text

	.global	sai_vdp_init
sai_vdp_init:
	lea	vdp_init_reg_tbl(pc), a0
	lea	g_sai_vdp_reg_mode, a1
	.rept	4/2
	move.l	(a0)+, (a1)+
	.endr
	move.l	#VRAM_SCRA_BASE_DEFAULT, g_sai_vdp_ntbase
	move.l	#VRAM_SCRB_BASE_DEFAULT, g_sai_vdp_ntbase+4
	move.l	#VRAM_SCRW_BASE_DEFAULT, g_sai_vdp_ntbase+8
	move.l	#VRAM_SPR_BASE_DEFAULT, g_sai_vdp_sprbase
	move.l	#VRAM_HSCR_BASE_DEFAULT, g_sai_vdp_hsbase

	calla6_safe	sai_min_vdp_init

	rts

; a6.l = return
	.global	sai_min_vdp_init
sai_min_vdp_init:
	lea	VDP_BASE, a1
	lea	vdp_init_reg_tbl(pc), a0
0:
	move.w	(a0)+, d1
	bpl.s	1f
	move.w	d1, VDP_OFFS_CTRL(a1)
	bra.s	0b
1:
	jmp	(a6)

vdp_init_reg_tbl:
	dc.w	VDP_REGST(VDP_MODESET1,  VDP_MODESET1_DEFAULT)
	dc.w	VDP_REGST(VDP_MODESET2,  VDP_MODESET2_DEFAULT)
	dc.w	VDP_REGST(VDP_MODESET3,  VDP_MODESET3_DEFAULT)
	dc.w	VDP_REGST(VDP_MODESET4,  VDP_MODESET4_DEFAULT)
	dc.w	VDP_REGST(VDP_SCRABASE,  ((VRAM_SCRA_BASE_DEFAULT >> VDP_SCRA_SHIFT) << 3))
	dc.w	VDP_REGST(VDP_SCRBBASE,  (VRAM_SCRB_BASE_DEFAULT >> VDP_SCRB_SHIFT))
	dc.w	VDP_REGST(VDP_SPRBASE,   (VRAM_SPR_BASE_DEFAULT >> VDP_SPR_SHIFT))
	dc.w	VDP_REGST(VDP_SCRWBASE,  ((VRAM_SCRW_BASE_DEFAULT >> VDP_SCRW_SHIFT) << 1))
	dc.w	VDP_REGST(VDP_HSCRBASE,  (VRAM_HSCR_BASE_DEFAULT >> VDP_HSCR_SHIFT))
	dc.w	VDP_REGST(VDP_PLANESIZE, VDP_PLANESIZE_64x32)
	dc.w	VDP_REGST(VDP_WINHORI,   $1F)
	dc.w	VDP_REGST(VDP_WINVERT,   $1F)
	dc.w	VDP_REGST(VDP_AUTOINC,   $02)
	dc.w	VDP_REGST(VDP_BGCOL,     $00)
	dc.w	VDP_REGST(VDP_HINTC,     $FF)
	dc.w	0  ; end marker

	.global	sai_vdp_clear_vram
sai_vdp_clear_vram:
	calla6_safe	sai_min_vdp_init
	rts

; a6.l = return
	.global	sai_min_vdp_clear_vram
sai_min_vdp_clear_vram:
	lea	VDP_BASE, a1
	move.l	#VDP_CTRL_ADDR(0)|VDP_VRAM_ADDR_CMD, VDP_OFFS_CTRL(a1)  ; Start at zero
	move.w	#VDP_REGST(VDP_AUTOINC, $02), VDP_OFFS_CTRL(a1)  ; Word increment
	moveq	#0, d0
	; Rept of 2 is used because IIRC the FIFO is four words long.
	move.w	#(VRAM_SIZE_128K / (4*2)), d1
0:
	.rept	2
	move.l	d0, VDP_OFFS_DATA(a1)
	.endr
	dbf	d1, 0b
	jmp	(a6)

	.global	sai_vdp_update_scroll_base
sai_vdp_update_scroll_base:
	lea	VDP_BASE, a1
	lea	g_sai_vdp_ntbase, a0
	; Scroll A
	move.w	(a0)+, d1  ; Keep for 128k mode bits
	moveq	#0, d0
	move.b	(a0), d0  ; lower bits for SCRA, read this way to shift by 8
	addq.l	#2, a0  ; 
	lsr.w	#VDP_SCRA_SHIFT-8-3, d0  ; Shift into place, offset weirdly
	andi.w	#$FFF8, d0  ; Mask off lower 3 bits
	ori.w	#VDP_REGST(VDP_SCRABASE, 0), d0
	move.w	d0, VDP_OFFS_CTRL(a1)
	; Scroll A and B's 16th bit for 128kB VRAM mode
	andi.w	#$0001, d1  ; PA0 in place
	move.w	(a0)+, d0  ; check for PB4
	andi.w	#$0001, d0
	beq.s	0f
	ori.w	#(1<<4), d1  ; PB4
0:
	ori.w	#VDP_REGST(VDP_128_BPCGA, 0), d1
	move.w	d1, VDP_OFFS_CTRL(a1)
	; Scroll B
	moveq	#0, d0
	move.b	(a0), d0  ; another byte read into place for -8 shift
	addq.l	#2, a0
	lsr.w	#VDP_SCRB_SHIFT-8, d0  ; Shift into place, offset weirdly
	ori.w	#VDP_REGST(VDP_SCRBBASE, 0), d0
	move.w	d0, VDP_OFFS_CTRL(a1)
	; Window
	moveq	#0, d0
	move.b	2(a0), d0
	addq.l	#4, a0
	lsr.w	#VDP_SCRW_SHIFT-8-1, d0  ; Shift into place, offset weirdly
	andi.w	#$FFFE, d0
	ori.w	#VDP_REGST(VDP_SCRWBASE, 0), d0
	move.w	d0, VDP_OFFS_CTRL(a1)
	; Sprite
	move.l	(a0)+, d0
	andi.w	#$0001, d0
	beq.s	0f
	andi.w	#(1<<5), d0  ; SP5, bit 16 of sprite table addr for 128k mode.
0:
	ori.w	#VDP_REGST(VDP_128_SPCGA, 0), d0
	move.w	d0, VDP_OFFS_CTRL(a1)
	; Horizontal scroll
	move.l	(a0)+, d0
	moveq	#VDP_HSCR_SHIFT, d1
	lsr.l	d1, d0
	ori.w	#VDP_REGST(VDP_HSCRBASE, 0), d0
	move.w	d0, VDP_OFFS_CTRL(a1)
	rts

	.global	sai_vdp_debug_set
; d1.w = number
; d0.w = number
sai_vdp_debug_port_sel:
	lsl.w	#8, d1
	move.w	d1, (VDP_DBG_SEL).l
	ori.b	#0, d1
	move.w	d0, (VDP_DBG_DATA).l
	rts

; saikodev megadrive and C2 startup
#include "sai/boot/memcheck.h"
#include "sai/input.h"
#include "sai/macro.h"
#include "sai/memmap.h"
#include "sai/target.h"
#include "sai/md/io.h"
#include "sai/md/vdp.h"

#if SAI_TARGET == SAI_TARGET_C2
#include "sai/c2/io.h"
#else
#include "sai/md/io.h"
#endif  // SAI_TARGET

	.extern	sai_crt0_begin

	.section	.text.keepboot

	.global	start
	.global	_start

	.global	startup_err

; Entry point
; Routines here do not use a call stack, but instead store the return address in
; the a6 register; until the WRAM test has completed it is not assumed that the
; RAM actually works.
	.org	$200
_start:
start:
	move.w	#$2700, sr
	lea	__stack, sp

#if SAI_TARGET == SAI_TARGET_MD
	calla6	sai_min_tmss_init
	calla6	sai_min_md_z80_init
	calla6	sai_min_md_pad_init
#elif SAI_TARGET==SAI_TARGET_C2
	calla6	sai_c2_min_init
#endif  // MDK_TARGET_C2

	calla6	sai_min_psg_init
	calla6	sai_min_vdp_init
	calla6	sai_min_input_init
	
	move.w	#$5555, d0
	move.w	#(WRAM_SIZE/2), d1
	lea	WRAM_BASE, a0
	calla6	sai_min_memcheck
	bne.w	startup_err

	move.w	#$AAAA, d0
	move.w	#(WRAM_SIZE/2), d1
	lea	WRAM_BASE, a0
	calla6	sai_min_memcheck
	bne.w	startup_err

softreset:
	jmp	sai_crt0_begin

startup_err:
#if SAI_TARGET == SAI_TARGET_C2
	; TODO: Start button to recovery from error or something
	bra.w	start
#else
	move.l	#$00400040, (MD_IO_CTRL1-1).l  ; Set TH pin as an output
	move.b	#$00, (MD_IO_DATA1).l  ; TH low
	btst	#5, (MD_IO_DATA1).l  ; Check start button
	bne.s	startup_err
startup_err_wait_start_release:
	btst	#5, (MD_IO_DATA1).l  ; Check start button
	beq.s	startup_err_wait_start_release
#endif
	bra.w	start

#if SAI_TARGET == SAI_TARGET_MD
	.global	sai_min_tmss_init
; a6.l = return
sai_min_tmss_init:
	; TMSS
	move.b	MD_IO_VERSION, d0
	andi.b	#$0F, d0
	beq.s	0f
	move.l	#$53454741, TMSS_PORT  ; "SEGA"
0:
	jmp	(a6)
#endif


;

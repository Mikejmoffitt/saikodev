#include "sai/memmap.h"
#include "sai/target.h"
#include "sai/md/vdp.h"
#include "sai/md/io.h"
;
	
	.struct	0

; Parameters in DmaCmd struct
DmaCmd.stride:	ds.w 1
DmaCmd.len1:	ds.w 1
DmaCmd.len2:	ds.w 1
DmaCmd.src1:	ds.w 1
DmaCmd.src2:	ds.w 1
DmaCmd.src3:	ds.w 1
DmaCmd.ctrl32:	ds.l 1
DmaCmd.len:
	.section	.text

; a0.l = command
	.global	sai_vdp_dma_process_cmd
sai_vdp_dma_process_cmd:
	lea	VDP_BASE, a1
	; Wait for another DMA to be done.
0:
	move.w	VDP_OFFS_STATUS(a1), d0
	andi.w	#VDP_STATUS_DMA, d0
	bne.s	0b

	lea	VDP_OFFS_CTRL(a1), a1
	; A0 holds the DMA command, with precalculated register values.
	move.w	DmaCmd.src3(a0), d0
	move.w	(a0)+, (a1)  ; DmaCmd.stride
	move.l	(a0)+, (a1)  ; DmaCmd.len1/len2
	tst.b	d0
	bmi.s	dma_fill
	move.l	(a0)+, (a1)  ; DmaCmd.src1/2
	addq.w	#2, a0  ; Skip src3, already read it
	move.w	d0, (a1)  ; src3

#if SAI_TARGET==SAI_TARGET_MD
	SAI_MD_Z80_BUSREQ_WAIT
#endif  // SAI_TARGET
	move.l	(a0), (a1)   ; DmaCmd.ctrl32
#if SAI_TARGET==SAI_TARGET_MD
	SAI_MD_Z80_BUSREL
#endif  // SAI_TARGET
	rts

dma_fill:
	subq	#DmaCmd.src1, a0  ; walk back
	move.w	d0, (a1)  ; PRM_SRC3

#if SAI_TARGET==SAI_TARGET_MD
	SAI_MD_Z80_BUSREQ_WAIT
#endif  // SAI_TARGET

	move.l	DmaCmd.ctrl32(a0), (a1)
	move.w	DmaCmd.src1(a0), VDP_OFFS_DATA-VDP_OFFS_CTRL(a1)  ; data
#if SAI_TARGET==SAI_TARGET_MD
	SAI_MD_Z80_BUSREL
#endif  // SAI_TARGET
0:
	btst	#1, 1(a1)
	bne.s	0b
	rts

#include	"sai/toa/gcu.h"
#include	"sai/toa/gcu_spr.h"
#include	"sai/toa/gcu_bg.h"
#include	"sai/toa/hw.h"
#include	"sai/macro.h"
#include	"sai/input.h"

#define GCU_PLANE_BASE_X 0x1D6
#define GCU_PLANE_BASE_Y 0x1EF

	.section	.bss

	.global g_sai_gcu_scroll
; User scroll configuration.
g_sai_gcu_scroll:              ds.w 4*SaiGcuPlaneCfg.len/2

; Plane base offsets.
s_scroll_offs:                 ds.w 4*SaiGcuPlaneCfg.len/2

; Due to the sprite framebuffer a frame of delay must be added to the scroll.
; This holds the sum of the offset + scroll setting from the prior frame.
s_scroll_out_buffer:           ds.w 4*SaiGcuPlaneCfg.len/2

	.section	.text


	.macro	GCU_CLEAR_VRAM_WORDS baseaddr, words
	; Erase sprite table VRAM
0:
	btst	#GCU_STATUS_BLANKING_BIT, GCU_STATUS_OFFS(a1)
	bne.b	0b

	move.w	\baseaddr, GCU_ADDR_OFFS(a1)
	moveq	#0, d0
	move.w	#(\words/2)-1, d1
0:
	btst	#GCU_STATUS_BLANKING_BIT, GCU_STATUS_OFFS(a1)
	bne.b	0b

	.rept	2
	move.w	d0, GCU_DATA_OFFS(a1)
	.endr
	dbf	d1, 0b 
	.endm

; clobbers a2.
	.global	sai_min_gcu_init
sai_min_gcu_init:
	; Short initial delay
	moveq	#-1, d0
0:
	.rept	3
	nop
	.endr
	dbf	d0, 0b
	moveq	#GCU_REG_SCROLL_A_H, d0
	lea	GCU_BASE, a1
	; Configuration registers
	move.w	#GCU_REG_CONFIG, GCU_REG_ADDR_OFFS(a1)
	; There's no reset pin! Setting either of these bits causes the display
	; to go blank, and for interrupts to stop firing. All titles using the
	; GCU poke pin 0, and then bits 0 and 1 together. Some reverse this
	; order.
	move.w	#SAI_BITVAL(GCU_CONFIG_RESET1_BIT)|SAI_BITVAL(GCU_CONFIG_RESET0_BIT), GCU_REG_DATA_OFFS(a1)
	move.w	#SAI_BITVAL(GCU_CONFIG_RESET1_BIT), GCU_REG_DATA_OFFS(a1)
	; After releasing the reset bits, every title sets bit 14. It is not
	; clear what this does, and not setting it does not have any obvious
	; consequences.
	move.w	#SAI_BITVAL(GCU_CONFIG_B14_BIT), GCU_REG_DATA_OFFS(a1)

	; Scroll setup
	lea	scroll_base_tbl(pc), a0
	lea	s_scroll_offs, a2
	moveq	#8-1, d1  ; eight scroll regs
0:
	; register select
	move.w	d0, GCU_REG_ADDR_OFFS(a1)
	; read scroll value and send to GCU as well as store in offset table
	swap	d0
	move.w	(a0)+, d0
	move.w	d0, GCU_REG_DATA_OFFS(a1)
	move.w	d0, (a2)+
	swap	d0
	addq.w	#1, d0
	dbf	d1, 0b

	GCU_CLEAR_VRAM_WORDS GCU_VRAM_A_BASE, GCU_BG_PAGE_WORDS
	GCU_CLEAR_VRAM_WORDS GCU_VRAM_B_BASE, GCU_BG_PAGE_WORDS
	GCU_CLEAR_VRAM_WORDS GCU_VRAM_C_BASE, GCU_BG_PAGE_WORDS
	GCU_CLEAR_VRAM_WORDS GCU_VRAM_SPR_BASE, GCU_SPR_PAGE_WORDS

	; Initial IRQ ack
	moveq	#GCU_REG_IRQ_ACK, d0
	move.w	d0, GCU_REG_ADDR_OFFS(a1)
	move.w	d0, GCU_REG_DATA_OFFS(a1)

	jmp	(a6)

; Each plane needs a 2px horizontal offset as it takes 2px of time to fetch the
; nametable and tile data for each plane in turn. The GCU pipelines the three
; planes serially this way. Rather than correct for the timing offset in the
; hardware, this is the responsibility of the programmer.
scroll_base_tbl:
	dc.w	GCU_PLANE_BASE_X+0, GCU_PLANE_BASE_Y    ; A
	dc.w	GCU_PLANE_BASE_X+2, GCU_PLANE_BASE_Y    ; B
	dc.w	GCU_PLANE_BASE_X+4, GCU_PLANE_BASE_Y    ; C
	dc.w	GCU_PLANE_BASE_X-10+GCU_SPR_STATIC_OFFS, GCU_PLANE_BASE_Y+GCU_SPR_STATIC_OFFS  ; S

;
; Initialization
;

	.global	sai_gcu_init
sai_gcu_init:
	; The init function clobbers a2 as well.
	movem.l	a2/a6, -(sp)
	calla6 sai_min_gcu_init
	movem.l	(sp)+, a2/a6
	rts

	.global	sai_gcu_on_vbl
sai_gcu_on_vbl:
; Write scroll to GCU
	move.l	a2, -(sp)
	lea	s_scroll_out_buffer, a0
	lea	GCU_BASE, a1
	lea	s_scroll_offs, a2

	moveq	#GCU_REG_SCROLL_A_H, d0
gcu_scroll_set_loop:
	move.w	d0, GCU_REG_ADDR_OFFS(a1)  ; regsel
	move.w	(a0)+, d1  ; user scroll
	add.w	(a2)+, d1  ; += base scroll
	andi.w	#$1FF, d1  ; wrap (TODO: is this necessary?)
	move.w	d1, GCU_REG_DATA_OFFS(a1)
	cmpi.w	#GCU_REG_SCROLL_S_V, d0
	beq.s	0f
	addq.w	#1, d0
	bra.s	gcu_scroll_set_loop
0:
	move.l	(sp)+, a2
; Push scroll values to buffer
	movem.l	g_sai_gcu_scroll, d0-d1/a0-a1
	movem.l	d0-d1/a0-a1, s_scroll_out_buffer
	rts

;
; Plane VRAM clear
;
	.global	sai_gcu_clear_plane
sai_gcu_clear_plane:
	lea	GCU_BASE, a1
	move.w	4+2(sp), d0
	add.w	d0, d0
	add.w	d0, d0
	move.w	gcu_plane_addr_tbl(pc, d0.w), d1
	move.w	gcu_plane_addr_tbl+2(pc, d0.w), d0
	move.w	d0, GCU_ADDR_OFFS(a1)
	moveq	#0, d0
0:
	btst	#GCU_STATUS_BLANKING_BIT, GCU_STATUS_OFFS(a1)
	bne.b	0b

	.rept	4
	move.w	d0, GCU_DATA_OFFS(a1)
	.endr
	dbf	d1, 0b
	rts

gcu_plane_addr_tbl:
	dc.w GCU_VRAM_A_BASE,   ((GCU_BG_PAGE_WORDS)/4)-1
	dc.w GCU_VRAM_B_BASE,   ((GCU_BG_PAGE_WORDS)/4)-1
	dc.w GCU_VRAM_C_BASE,   ((GCU_BG_PAGE_WORDS)/4)-1
	dc.w GCU_VRAM_SPR_BASE, ((GCU_SPR_PAGE_WORDS)/4)-1

#include	"sai/toa/gcu.h"
#include	"sai/toa/hw.h"
#include	"sai/macro.h"
#include	"sai/input.h"

#define GCU_PLANE_BASE_X 0x1D6
#define GCU_PLANE_BASE_Y 0x1EF

	.section	.bss

; Sprite support
	.global	g_sai_gcu_spr_count
g_sai_gcu_spr_count:        ds.w 1
	.global	g_sai_gcu_spr_next
g_sai_gcu_spr_next:         ds.w 1  ; VRAM address of next sprite
s_sai_gcu_spr_next_prev:    ds.w 1  ; For erasing unused slots from the last frame.


	.global g_sai_gcu_scroll
; User scroll configuration.
g_sai_gcu_scroll: ds.w 4*SaiGcuPlaneCfg.len/2
; Plane base offsets.
s_scroll_offs:    ds.w 4*SaiGcuPlaneCfg.len/2
; Due to the sprite framebuffer a frame of delay must be added to the scroll.
; This holds the sum of the offset + scroll setting from the prior frame.
s_scroll_out_buffer:    ds.w 4*SaiGcuPlaneCfg.len/2

	.section	.text


	.macro	GCU_CLEAR_VRAM_WORDS baseaddr, words
	; Erase sprite table VRAM
	move.w	\baseaddr, GCU_ADDR_OFFS(a1)
	moveq	#0, d0
	move.w	#(\words/2)-1, d1
0:
	btst	#GCU_STATUS_BLANKING_BIT, GCU_STATUS_OFFS(a1)
	bne.b	0b

	.rept	2
	move.w	d0, GCU_DATA_OFFS(a1)
	.endr
	dbf	d1, 0b 
	.endm

; clobbers a2.
	.global	sai_min_gcu_init
sai_min_gcu_init:
	moveq	#GCU_REG_SCROLL_A_H, d0
	lea	GCU_BASE, a1
	; Configuration registers
	lea	config_tbl(pc), a0
	move.w	#GCU_REG_INITIALIZE, GCU_REG_ADDR_OFFS(a1)
	moveq	#3-1, d1  ; three config register sections
0:
	move.w	(a0)+, GCU_REG_DATA_OFFS(a1)
	dbf	d1, 0b

	; Scroll setup
	lea	scroll_base_tbl(pc), a0
	lea	s_scroll_offs, a2
	moveq	#8-1, d1  ; eight scroll regs
0:
	; register select
	move.w	d0, GCU_REG_ADDR_OFFS(a1)
	; read scroll value and send to GCU as well as store in offset table
	swap	d0
	move.w	(a0)+, d0
	move.w	d0, GCU_REG_DATA_OFFS(a1)
	move.w	d0, (a2)+
	swap	d0
	addq.w	#1, d0
	dbf	d1, 0b

	GCU_CLEAR_VRAM_WORDS GCU_VRAM_A_BASE, GCU_VRAM_PAGE_SIZE
	GCU_CLEAR_VRAM_WORDS GCU_VRAM_B_BASE, GCU_VRAM_PAGE_SIZE
	GCU_CLEAR_VRAM_WORDS GCU_VRAM_C_BASE, GCU_VRAM_PAGE_SIZE
	GCU_CLEAR_VRAM_WORDS GCU_VRAM_SPR_BASE, (GCU_SPR_COUNT*GcuSpr.len/2)

	; Initial IRQ ack
	moveq	#GCU_REG_IRQ_ACK, d0
	move.w	d0, GCU_REG_ADDR_OFFS(a1)
	move.w	d0, GCU_REG_DATA_OFFS(a1)

	jmp	(a6)

; Each plane needs a 2px horizontal offset as it takes 2px of time to fetch the
; nametable and tile data for each plane in turn. The GCU pipelines the three
; planes serially this way. Rather than correct for the timing offset in the
; hardware, this is the responsibility of the programmer.
scroll_base_tbl:
	dc.w	GCU_PLANE_BASE_X+0, GCU_PLANE_BASE_Y    ; A
	dc.w	GCU_PLANE_BASE_X+2, GCU_PLANE_BASE_Y    ; B
	dc.w	GCU_PLANE_BASE_X+4, GCU_PLANE_BASE_Y    ; C
	dc.w	GCU_PLANE_BASE_X-10+GCU_SPR_STATIC_OFFS, GCU_PLANE_BASE_Y+GCU_SPR_STATIC_OFFS  ; S

; The meaning of all bits is not known, but some patterns can be found in all
; words of the configuration stream. It is thought that this data is shited in
; to a larger configuration register.
;
; fedc ba98 7654 3210
; .l.. .... .... .... Configuration data latch (end of stream) ?
; ..s. .... .... .... GCU Slave move
; .... ..h. .... .... Vertical sync resets horizontal sync counter...?
; .... .... .... SSSS Thought to be some sort of selection possibly
config_tbl:
	dc.w	$0003
	dc.w	$0002
	dc.w	$4000

;
; Initialization
;

	.global	sai_gcu_init
sai_gcu_init:
	; The init function clobbers a2 as well.
	movem.l	a2/a6, -(sp)
	calla6 sai_min_gcu_init
	movem.l	(sp)+, a2/a6
	rts

	.global	sai_gcu_on_vbl
sai_gcu_on_vbl:
;
; Write scroll to GCU
;
	move.l	a2, -(sp)
	lea	s_scroll_out_buffer, a0
	lea	GCU_BASE+GCU_REG_ADDR_OFFS, a1
	lea	s_scroll_offs, a2

	moveq	#GCU_REG_SCROLL_A_H, d0
gcu_scroll_set_loop:
	move.w	d0, GCU_REG_ADDR_OFFS-GCU_REG_ADDR_OFFS(a1)  ; regsel
	move.w	(a0)+, d1  ; user scroll
	add.w	(a2)+, d1  ; += base scroll
	andi.w	#$1FF, d1  ; wrap (TODO: is this necessary?)
	move.w	d1, GCU_REG_DATA_OFFS-GCU_REG_ADDR_OFFS(a1)
	cmpi.w	#GCU_REG_SCROLL_S_V, d0
	beq.s	0f
	addq.w	#1, d0
	bra.s	gcu_scroll_set_loop
0:
	move.l	(sp)+, a2

;
; Push scroll values to buffer
;
	movem.l	g_sai_gcu_scroll, d0-d1/a0-a1
	movem.l	d0-d1/a0-a1, s_scroll_out_buffer

;
; Ack IRQ
;
	moveq	#GCU_REG_IRQ_ACK, d0
	move.w	d0, GCU_BASE+GCU_REG_ADDR_OFFS
	move.w	d0, GCU_BASE+GCU_REG_DATA_OFFS
	rts

;
; Sprite code
;

	.global	sai_gcu_spr_init
sai_gcu_spr_init:
	move.w	#GCU_SPR_COUNT-1, d1

	move.w	#GCU_VRAM_SPR_BASE, d0
	move.w	d0, g_sai_gcu_spr_next
	add.w	#GCU_SPR_COUNT*GcuSpr.len, d0
	move.w	d0, s_sai_gcu_spr_next_prev

	moveq	#0, d0
	move.w	d0, g_sai_gcu_spr_count

; d0.w = sprite VRAM address
; d1.w = count
sai_gcu_spr_init_erase:
	movem.l	d2-d3, -(sp)
	lea	GCU_BASE+GCU_DATA_OFFS, a0
	moveq	#GCU_STATUS_BLANKING_BIT, d3
	moveq	#0, d2  ; blank data


sai_gcu_spr_init_loop:
; vdisp wait
0:
	btst	d3, GCU_STATUS_OFFS+1-GCU_DATA_OFFS(a0)
	bne.s	0b
; address and data
	move.w	d0, GCU_ADDR_OFFS-GCU_DATA_OFFS(a0)
	move.w	d2, GCU_DATA_OFFS-GCU_DATA_OFFS(a0)
	addq.w	#GcuSpr.len/2, d0
	dbf	d1, sai_gcu_spr_init_loop
	movem.l	(sp)+, d2-d3

sai_gcu_spr_init_ret:
	rts

	.global	sai_gcu_spr_finish
sai_gcu_spr_finish:
	move.w	g_sai_gcu_spr_next, d0
	move.w	#GCU_VRAM_SPR_BASE, g_sai_gcu_spr_next
	clr.w	g_sai_gcu_spr_count
	move.w	s_sai_gcu_spr_next_prev, d1
	move.w	d0, s_sai_gcu_spr_next_prev
	; Figure out how many slots linger from the last draw.
	cmp.w	d1, d0
	bcc.s	sai_gcu_spr_init_ret  ; If now >= prev, skip the clear

	; Address math to get sprite count
	sub.w	d0, d1
	lsr.w	#2, d1
	subq.w	#1, d1

	bra.w	sai_gcu_spr_init_erase

	.global	sai_gcu_clear_plane
.global sai_gcu_clear_plane
	lea	GCU_BASE, a1
	move.w	4+2(sp), d0
	add.w	d0, d0
	add.w	d0, d0
	move.w	gcu_plane_addr_tbl(pc, d0.w), d1
	move.w	gcu_plane_addr_tbl+2(pc, d0.w), d0
	move.w	d0, GCU_ADDR_OFFS(a1)
	moveq	#0, d0
0:
	btst	#GCU_STATUS_BLANKING_BIT, GCU_STATUS_OFFS(a1)
	bne.b	0b

	.rept	2
	move.w	d0, GCU_DATA_OFFS(a1)
	.endr
	dbf	d1, 0b
	rts

gcu_plane_addr_tbl:
	dc.w GCU_VRAM_A_BASE,   ((GCU_VRAM_PAGE_SIZE)/2)-1
	dc.w GCU_VRAM_B_BASE,   ((GCU_VRAM_PAGE_SIZE)/2)-1
	dc.w GCU_VRAM_C_BASE,   ((GCU_VRAM_PAGE_SIZE)/2)-1
	dc.w GCU_VRAM_SPR_BASE, (((GCU_SPR_COUNT*GcuSpr.len/2))/2)-1

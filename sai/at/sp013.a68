#include	"sai/at/sp013.h"
#include	"sai/macro.h"

	.section	.bss
	.global	g_sai_sp013_spr_next
	.global	g_sai_sp013_state
g_sai_sp013_spr_next: ds.l 1
g_sai_sp013_state:    ds.b Sp013State.len

s_last_obj_even: ds.l 1
s_last_obj_odd:  ds.l 1
s_obj_bank: ds.w 1

	.section	.text

	.global	sai_sp013_init
sai_sp013_init:
	calla6_safe sai_min_sp013_init

	clr.w	s_obj_bank
	bsr.w	sai_sp013_spr_reset

	lea	g_sai_sp013_state, a0
	move.l	#((SP013_SPRDX_DEFAULT)<<16)|SP013_SPRDY_DEFAULT, (a0)+
	move.l	#((SP013_SPRSX_DEFAULT)<<16)|SP013_SPRSY_DEFAULT, (a0)+
	rts

	.global	sai_min_sp013_init
sai_min_sp013_init:
	; Zero out the sub-cpu control regs I don't yet know about
	moveq	#0, d0
	move.w	d0, s_obj_bank
	moveq	#$D-1, d1
	lea	SP013_CTRL_BASE+SP013_OFFS_UNK0C, a1
0:
	move.w	d0, (a1)+
	dbf	d0, 0b

	; Format setup
	moveq	#0, d0
	moveq	#$18-1, d1
	lea	format_data(pc), a0
	lea	SP013_CTRL_BASE+SP013_OFFS_FORMAT, a1
0:
	move.b	(a0)+, d0
	move.w	d0, (a1)
	dbf	d1, 0b

	move.w	#SP013_CONFIG_DEFAULT, SP013_CTRL_BASE+SP013_OFFS_CONFIG

	; More magic, possibly resetting a sub CPU that doesn't exist.
	move.w	#$1000, SP013_CTRL_BASE+SP013_OFFS_UNK20
	move.w	#$69, SP013_CTRL_BASE+SP013_OFFS_WDOG
	move.w	#$0, SP013_CTRL_BASE+SP013_OFFS_UNK20

	; Sprite offset values
	move.w	#SP013_SPRDX_DEFAULT, SP013_CTRL_BASE+SP013_OFFS_SPRDX
	move.w	#SP013_SPRDY_DEFAULT, SP013_CTRL_BASE+SP013_OFFS_SPRDY
	move.w	#SP013_SPRSX_DEFAULT, SP013_CTRL_BASE+SP013_OFFS_SPRSX
	move.w	#SP013_SPRSY_DEFAULT, SP013_CTRL_BASE+SP013_OFFS_SPRSY

	; Clear sprite RAM
	moveq	#0, d0
	lea	SP013_VRAM_BASE, a0
	move.l	a0, g_sai_sp013_spr_next
	move.l	a0, s_last_obj_even
	move.l	#SP013_VRAM_BASE + (SP013_BANK_SIZE*2), s_last_obj_odd
	move.w	#(SP013_VRAM_SIZE/(4*4))-1, d1
0:
	.rept	4
	move.l	d0, (a0)+
	.endr
	dbf	d1, 0b

	; Set sprite next pointer

	jmp	(a6)
format_data:
	dc.b $3F  ; 0
	dc.b $3E  ; 1
	dc.b $38  ; 2
	dc.b $D   ; 3
	dc.b $1D  ; 4
	dc.b 8    ; 5
	dc.b 2    ; 6
	dc.b $3A  ; 7
	dc.b $31  ; 8
	dc.b $34  ; 9
	dc.b $3F  ; $A
	dc.b $A   ; $B
	dc.b $1F  ; $C
	dc.b $17  ; $D
	dc.b $11  ; $E
	dc.b $29  ; $F
	dc.b $F   ; $10
	dc.b $30  ; $11
	dc.b $16  ; $12
	dc.b $33  ; $13
	dc.b $37  ; $14
	dc.b $1C  ; $15
	dc.b $20  ; $16
	dc.b 4    ; $17

	.global	sai_sp013_finish
; The sprite list is terminated.
sai_sp013_finish:
	; A0 points to the last sprite entry that was written to.
	move.l	g_sai_sp013_spr_next, a0
	; Get the address of the last sprite we wrote to in this buffer.
	lea	s_last_obj_even, a1
	tst.w	s_obj_bank
	beq.s	0f
	addq.l	#4, a1  ; point to s_last_obj_odd
0:
	move.l	(a1), d1  ; d1 holds the previous max sprite address
	; Update max sprite address tracking
	move.l	a0, (a1)
	; Now if the previous > now, erase the sprites between
	movea.l	d1, a1
	move.w	#SP013_SPR_HIDE_POS, d0  ; xpos
	move.w	#$0101, d1  ; size field
0:
	.rept	4
	cmpa.l	a0, a1
	bcs.s	1f
	move.w	d0, Sp013Spr.x(a0)
	move.w	d1, Sp013Spr.size(a0)
	lea	Sp013Spr.len(a0), a0
	.endr
	bra.s	0b
1:
	; Swap bank and update pointer
	lea	SP013_VRAM_BASE, a0
	move.w	s_obj_bank, d0
	eori.w	#$0002, d0  ; Bank in $4000*2
	beq.s	0f
	lea	SP013_VRAM_BASE+(SP013_BANK_SIZE*2), a0
0:
	move.w	d0, s_obj_bank
	move.l	a0, g_sai_sp013_spr_next
	rts

	.global	sai_sp013_spr_reset
sai_sp013_spr_reset:
	lea	SP013_VRAM_BASE, a0
	move.l	a0, g_sai_sp013_spr_next
	moveq	#0, d0
	move.w	#(SP013_VRAM_SIZE/(4*4))-1, d1
0:
	.rept	4
	move.l	d0, (a0)+
	.endr
	dbf	d1, 0b
	rts

	.global	sai_sp013_on_vbl
sai_sp013_on_vbl:
	move.w	s_obj_bank, SP013_CTRL_BASE+SP013_OFFS_SPRBANK
	lea	g_sai_sp013_state, a0
	movem.l	(a0), d0-d1
	move.l	d0, SP013_CTRL_BASE+SP013_OFFS_SPRDX
	move.l	d1, SP013_CTRL_BASE+SP013_OFFS_SPRSX
	rts
